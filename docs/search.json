[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "UMN EEB Quant/Comp Repo",
    "section": "",
    "text": "Hello!\nThis site/book will serve as a repository for resources related to computational and quantitative workshop held for the University of Minnesota’s Ecology, Evolution, and Behavior Graduate Program through its “Friday Noon Seminar” series.\nIt is a “living document,” and thus will be subject to change and be updated over time."
  },
  {
    "objectID": "intro_iteration.html",
    "href": "intro_iteration.html",
    "title": "1  Intro to Iteration",
    "section": "",
    "text": "This workshop will be focused on iteration, or performing the same code numerous times, potentially on some range of values, in R. It assumes that you know most of the basics of R programming.\nR has various ways to iterate, including looping, using functions, and vectorization. We will go over each to some extent, with examples included. A general guideline for iterating is that if you are copying and pasting code multiple times, you may be better served with a loop or a function. We will cover the following:\n\nLoops\n\nTypes of loops: for, while, and repeat\nWhen to use which types of loops\nPotential downsides of using loops\nWhen use a loop is still necessary anyway\n\nFunctions and Functionals\n\nBenefits of functions\nHow to write functions\nHow to iterate functions with the purr package\nHow to iterate even faster with parallel computing\n\nVectorization\n\nBenefits of vectorization\nLimitations"
  },
  {
    "objectID": "loop_types.html",
    "href": "loop_types.html",
    "title": "2  Types of Loops",
    "section": "",
    "text": "The first method of iteration that most people learn is looping, or using flow control to rerun a block of code some number of times, or over a range of values. Many of you will be familiar with this, so we will just review it a bit.\nR has different type of loops, including for, while, and repeat.\n\n2.0.1 for loops\nfor loops are the most commonly used loop, as they are versatile to many contexts. They generally follow the form:\n\nfor (indexing_variable in range_of_values) {\n  some_function(some_argument = indexing_variable)\n}\n\nIn the first line, an indexing variable is created to keep track of iterations, and it iterates through the range of values provided.\nThen, some code is provided within brackets to be performed for each value in the range of values. Usually, the indexing variable will be referenced somehow in this code, but it doesn’t need to be if you are just doing the same exact thing several times.\nHere is a really silly working example:\n\n## square the numbers 1 through 5\nfor (i in 1:5) {\n  print(i^2)\n}\n\n[1] 1\n[1] 4\n[1] 9\n[1] 16\n[1] 25\n\n## of course you could just do this instead and get a more useable vector\n(1:5)^2\n\n[1]  1  4  9 16 25\n\n\nNow let’s look at a more interesting example. Let’s say you are interested in the effect of some independent variable on multiple dependent variables. First let’s simulate some fake data of greenhouse plant growth under two watering conditions:\n\n## create a data frame with 60 total plants and\n## -two treatment levels, control and drought\n## -plant heights, masses, and seed masses sampling from a normal distribution\nplant_data &lt;- data.frame(treatment = rep(c(\"control\",\"drought\"), each = 30),\n                         height_cm = rnorm(n = 60, mean = rep(c(12,8), each = 30), sd = 2),\n                         dry_biomass_g = rnorm(60, mean = rep(c(50, 40), each = 30), sd = 6),\n                         seed_mass_g = rnorm(60, mean = rep(c(30, 20), each = 30), sd = 4))\n\nNow we are probably interested in how the watering influences these variables (i.e., with a t-test), but we don’t want to write the code, and then copy and paste it twice. Here’s how we use a for loop:\n\n## create a vector of dependent variables to loop over\ndep_vars &lt;- c(\"height_cm\", \"dry_biomass_g\", \"seed_mass_g\")\n\n## pre allocate a list to store results\nresult_list &lt;- vector(mode = \"list\", length = length(dep_vars))\n\n## let's name the list as well\nnames(result_list) &lt;- dep_vars\n\n## set up a loop to iterate through variables\nfor (i in dep_vars) {\n  ## store t test results in our list\n  result_list[[i]] &lt;- t.test(plant_data[,i] ~ plant_data[,\"treatment\"])\n}\n\n## check out the results!\nresult_list\n\n$height_cm\n\n    Welch Two Sample t-test\n\ndata:  plant_data[, i] by plant_data[, \"treatment\"]\nt = 6.951, df = 55.032, p-value = 4.525e-09\nalternative hypothesis: true difference in means between group control and group drought is not equal to 0\n95 percent confidence interval:\n 2.756530 4.989863\nsample estimates:\nmean in group control mean in group drought \n            11.371913              7.498717 \n\n\n$dry_biomass_g\n\n    Welch Two Sample t-test\n\ndata:  plant_data[, i] by plant_data[, \"treatment\"]\nt = 5.539, df = 57.243, p-value = 7.988e-07\nalternative hypothesis: true difference in means between group control and group drought is not equal to 0\n95 percent confidence interval:\n  5.841609 12.455876\nsample estimates:\nmean in group control mean in group drought \n             49.55840              40.40966 \n\n\n$seed_mass_g\n\n    Welch Two Sample t-test\n\ndata:  plant_data[, i] by plant_data[, \"treatment\"]\nt = 10.008, df = 57.97, p-value = 3.031e-14\nalternative hypothesis: true difference in means between group control and group drought is not equal to 0\n95 percent confidence interval:\n  8.116532 12.175137\nsample estimates:\nmean in group control mean in group drought \n             30.03102              19.88518 \n\n\nWhen you are writing a for loop (especially ones more complex than the above), it can be helpful to first develop the code within the loop to more easily debug it. For example:\n\n## set the iterator variable to one of the values to be looped through\ni &lt;- dep_vars[1]\n\n## then try coding what you want to do repeatedly\ntest_result &lt;- t.test(plant_data[,i] ~ plant_data[,\"treatment\"])\ntest_result\n\n\n    Welch Two Sample t-test\n\ndata:  plant_data[, i] by plant_data[, \"treatment\"]\nt = 6.951, df = 55.032, p-value = 4.525e-09\nalternative hypothesis: true difference in means between group control and group drought is not equal to 0\n95 percent confidence interval:\n 2.756530 4.989863\nsample estimates:\nmean in group control mean in group drought \n            11.371913              7.498717 \n\n\nThis can be helpful because R, like most programming languages, is very particular about syntax. If you had tried to use the $ operator to select columns, you would have gotten an error:\n\n## this doesn't work because i is a character value in quotes, which is incompatible with $\nt.test(plat_data$i ~ plant_data$treatment)\n\nThere are some “common pitfalls” to writing for loops, which I hope I have avoided here. You can read about them in more detail here:\nhttps://adv-r.hadley.nz/control-flow.html#common-pitfalls\n\n\n2.0.2 while loops\nwhile loops are a bit less common, but can be useful in certain contexts (mostly simulation). They follow this form:\n\nwhile (some_condition == TRUE) {\n  some_function()\n}\n\nThe first line provides a conditional statement to be evaluated at each iteration, if it is met the loop will continue to run, if it is not met the loop will close.\nThere are two uses for while loop that I have found. The first is when there is some degree of randomness in how many iterations need to be run. Let’s say for example you want to simulate a population of organisms that aggregate in groups, but you want to allow the group sizes to vary while the global population size remains the about the same. In this case, you could use a while loop:\n\n## first let's set the population size to 0\nN &lt;- 0\n\n## and create an empty vector for group size\ngroups &lt;- NULL\n\n## and a counter variable\ncounter &lt;- 1\n\n## now let's start the while loop\nwhile (N &lt; 100) {\n  ## randomly generate a group size as a pull from a poisson distribution w/ a mean of 5\n  groups[counter] &lt;- rpois(n = 1, lambda = 5)\n  ## calculate total pop size\n  N &lt;- sum(groups)\n  ## increase counter\n  counter &lt;- counter + 1\n}\n\nIf you run that code multiple times, you’ll see that you will end up with different numbers of groups with different numbers of members. This could be useful for simulation models or parametric bootstrapping. However, you may also notice that the total population size here isn’t exactly constant. To keep it constant, you could do something like this:\n\n## first let's set the population size to 0\nN &lt;- 0\n\n## and create an empty vector for group size\ngroups &lt;- NULL\n\n## and a counter variable\ncounter &lt;- 1\n\n## now let's start the while loop\nwhile (N &lt; 100) {\n  ## calculate remaining population to fill\n  to_fill &lt;- 100 - sum(groups)\n  ## randomly generate a group size as a pull from a poisson distribution w/ a mean of 5\n  ## but if it is larger than the remaining population to fill, just fill it up exactly\n  groups[counter] &lt;- min(rpois(n = 1, lambda = 5), to_fill)\n  ## calculate total pop size\n  N &lt;- sum(groups)\n  ## increase counter\n  counter &lt;- counter + 1\n}\n\nNifty!\nThe other use of a while loop that I have found is for a brute force algorithm. Basically, if you have do something complex but don’t have the time or mental energy to figure out the precise algorithm to do it, you can do it the “stupid” way. This is basically like trying every combination on a lock until it opens. Computer scientists frown on these methods for being highly inefficient, but we are computer scientists. For ecology/evolution/behavior contexts, you might use a brute force while loops to try random combinations of data or sample sets of observations with many characteristics until you find a combination/set that meets highly specific criteria that you are looking for (e.g., subsampling a large dataset such that you sample randomly but also cover a wide range of treatment levels, sampling dates, etc.).\n\n\n2.0.3 repeat loops\nrepeat loops are a very basic sort of loop that simply do something over an over again until a condition is met, then they close. Here’s the form:\n\nrepeat {\n  some_function()\n  if (some_condition == TRUE) break\n}\n\nTo me they kind of seem like a while loop formatted differently. I suppose you could add multiple “break” points for different end conditions, but I believe you can add “break” commands to any type of loop.\nLet me know if you know of cases where repeat loops are effective!"
  },
  {
    "objectID": "when_loops.html",
    "href": "when_loops.html",
    "title": "3  When to Loop?",
    "section": "",
    "text": "Now you may have often heard that you should avoid using for loops because they are slow. This isn’t strictly true; it depends how you write them. It has to do with how R uses your computer’s working memory, but the details are probably not worth getting into. Generally if you avoid the “common pitfalls” linked in the last section, you should be writing loops that are plenty fast. Also, in my personal opinion, I’m not sure how important speed is for most of our work - since we’re not developing software or data pipelines for business purposes, we are more interested in the end result and less interested in how long it took our program to get there. All this to say, don’t worry about the for loops you use being inefficient. A good guideline might be: do what you need to do now to get your results, and maybe do it a little better next time.\nHowever, there are other reasons not to use for loops that I think are more compelling, and we’ll talk about them when we talk about functions. But sometimes you just have to use loops. How can you know?\nBasically -\nYou need to use a loop when the process of one iteration depends on the outcome of previous iteration/s.\nThe while loop we used in the last section is technically an example of a case where a loop is necessary, but let’s look at another clearer ecological example: discrete population growth.\nLet’s use one common formulation of discrete logistic growth:\n\\[\nN_{t+1} = N_t *e^{r(\\frac{K-N_t}{K})}\n\\]\nWhere N is population size, r is growth rate, and K is carrying capacity.\nAs you can see, that pesky Nt is involved in the calculation of Nt+1, or in other words, the process of calculation for one iteration/timestep depends on the outcome of the previous iteration/timestep. Thus we need to use a loop:\n\n## set growth rate, r, and carrying capacity K\nr &lt;- 1\nK &lt;- 100\n\n## set number of timesteps, t, and preallocate population size vector, N\nt &lt;- 20\nN &lt;- vector(mode = \"numeric\", length = t)\nN[1] &lt;- 1\n\n## loop through timesteps and calculate population size\n## note: we are considering t = 1 as initial pop size\nfor (i in 1:(t - 1)) {\n  N[i+1]  = N[i] * exp(r * ((K-N[i])/K))\n}\n\n## plot the output                                 \nplot(1:t, N, type = \"o\", xlab = \"t\")\n\n\n\n\nThis relatively simple loop is what powers this web app:\nhttps://cwojan.shinyapps.io/discrete_logistic_growth/\nCool!"
  }
]